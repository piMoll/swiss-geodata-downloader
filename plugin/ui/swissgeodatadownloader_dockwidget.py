# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SwissGeodataDownloaderDockWidget
                                 A QGIS plugin
 This plugin lets you comfortably download open geo data from sigstop.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-03-14
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Patricia Moll
        email                : pimoll.dev@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtWidgets import (QDockWidget, QListWidget, QFileDialog,
                                 QMessageBox)
from qgis.gui import QgsExtentGroupBox
from qgis.core import (QgsCoordinateReferenceSystem, QgsCoordinateTransform,
                       QgsProject, QgsPoint, QgsRectangle)
from .swissgeodatadownloader_dockwidget_base import Ui_SwissGeodataDownloaderDockWidgetBase
from .ui_utilities import (filesizeFormatter, getDateFromIsoString)
from ..core.api_datageoadmin import (API_EPSG, getDatasetList,
                                     getFileList, downloadFiles)


class SwissGeodataDownloaderDockWidget(QDockWidget, Ui_SwissGeodataDownloaderDockWidgetBase):

    closingPlugin = pyqtSignal()

    def __init__(self, interface, parent=None):
        """Constructor."""
        super(SwissGeodataDownloaderDockWidget, self).__init__(parent)
        self.setupUi(self)
        self.iface = interface

        # Initialize variables
        self.datasetList = {}
        self.currentDataset = {}
        self.selectMode = None
        self.fileList = []
        self.fileListFiltered = []
        self.currentFilter = 'all'
        self.outputPath = None
        
        # Coordinate system
        self.mapRefSys = self.iface.mapCanvas().mapSettings().destinationCrs()
        self.apiRefSys = QgsCoordinateReferenceSystem(API_EPSG)
        self.transformProj2Api = QgsCoordinateTransform(
            self.mapRefSys, self.apiRefSys, QgsProject.instance())
        self.transformApi2Proj = QgsCoordinateTransform(
            self.apiRefSys, self.mapRefSys, QgsProject.instance())
        
        # Init QgsExtentBoxGroup Widget
        self.guiExtentWidget: QgsExtentGroupBox
        self.guiExtentWidget.setOriginalExtent(self.iface.mapCanvas().extent(),
                                         self.mapRefSys)
        # Set current (=map view) extent
        self.guiExtentWidget.setCurrentExtent(self.iface.mapCanvas().extent(),
                                        self.mapRefSys)
        self.guiExtentWidget.setOutputExtentFromCurrent()
        # Activate option to update map canvas extent
        self.guiExtentWidget.setMapCanvas(self.iface.mapCanvas(),
                                          drawOnCanvasOption=False)

        # Deactivate unused ui-elements
        self.onUnselectDataset()
        
        # Load available datasets from api
        self.loadAvailableDatasets()
        
        # Connect signals
        self.guiDatasetList.currentItemChanged.connect(self.onDatasetSelected)
        self.guiFormat.currentTextChanged.connect(self.onOptionChanged)
        self.guiResolution.currentIndexChanged.connect(self.onOptionChanged)
        self.guiCoordsys.currentIndexChanged.connect(self.onOptionChanged)
        self.guiTimestamp.currentIndexChanged.connect(self.onOptionChanged)
        self.guiExtentWidget.extentChanged.connect(self.onExtentChanged)
        self.guiFullExtentChbox.clicked.connect(self.onUseFullExtentChanged)
        self.guiRequestListBtn.clicked.connect(self.onLoadFileList)
        self.guiDownloadBtn.clicked.connect(self.onDownloadFiles)
        self.guiFileType.currentIndexChanged.connect(self.onChangeFileType)
        QgsProject.instance().crsChanged.connect(self.onChangeMapRefSys)
        self.iface.mapCanvas().extentsChanged.connect(self.onMapExtentChange)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
    
    def onChangeMapRefSys(self):
        """Listen for map canvas reference system changes and apply to new
        crs to extent widget."""
        self.mapRefSys = self.iface.mapCanvas().mapSettings().destinationCrs()
        mapExtent: QgsRectangle = self.iface.mapCanvas().extent()
        self.updateExtentValues(mapExtent, self.mapRefSys)
    
    def onExtentChanged(self):
        self.resetFileList()
    
    def onMapExtentChange(self):
        """Show extent of current map view in extent widget."""
        if self.guiExtentWidget.extentState() == 1:
            # Only update widget if its current state is to display the map
            #  view extent
            if self.guiGroupExtent.isEnabled() and self.guiExtentWidget.isEnabled():
                # Check if extent widget is currently active
                mapExtent: QgsRectangle = self.iface.mapCanvas().extent()
                self.updateExtentValues(mapExtent, self.mapRefSys)
    
    def onUseFullExtentChanged(self):
        if self.guiFullExtentChbox.isChecked():
            self.updateSelectMode()
            self.guiExtentWidget.setDisabled(True)
        else:
            self.guiExtentWidget.setDisabled(False)
    
    def onChangeFileType(self, idx):
        if idx != -1:
            selectedFileType = self.guiFileType.itemText(idx)
            self.filterFileList(selectedFileType)
    
    def updateExtentValues(self, extent, refSys):
        self.guiExtentWidget.setCurrentExtent(extent, refSys)
        self.guiExtentWidget.setOutputExtentFromCurrent()
    
    def loadAvailableDatasets(self):
        """Call api to get a list of available datasets"""
        self.datasetList = getDatasetList()
        for dsId in self.datasetList.keys():
            self.guiDatasetList.addItem(dsId)
    
    def onDatasetSelected(self, item: QListWidget):
        """Set up ui according to the options of the selected dataset"""
        self.currentDataset = self.datasetList[item.text()]
        # Show dataset in search field
        self.guiSearchField.setText(self.currentDataset['id'])
        
        # Activate options and extent groups
        self.clearOptions()
        self.blockUiSignals()
        self.guiGroupOptions.setDisabled(False)
        self.guiGroupFiles.setDisabled(False)
        self.resetFileList()
        self.currentFilter = 'all'
        
        for optionKey, option in self.currentDataset['options'].items():
            if optionKey == 'format':
                self.guiFormat.addItems(option)
                self.guiFormatL.setDisabled(False)
                self.guiFormat.setDisabled(False)
            if optionKey == 'resolution':
                # Stringify resolution numbers
                optionStr = [str(r) for r in option]
                self.guiResolution.addItems(optionStr)
                self.guiResolutionL.setDisabled(False)
                self.guiResolution.setDisabled(False)
            if optionKey == 'coordsys':
                # Create a coordinate system object and get its friendly identifier
                coordSysList = [QgsCoordinateReferenceSystem(f'EPSG:{epsg}') for epsg in option]
                coordSysNames = [cs.userFriendlyIdentifier() for cs in coordSysList]
                self.guiCoordsys.addItems(coordSysNames)
                self.guiCoordsysL.setDisabled(False)
                self.guiCoordsys.setDisabled(False)
            if optionKey == 'timestamp':
                # Format ISO time string into nice dates
                optionStr = [getDateFromIsoString(ts) for ts in option]
                self.guiTimestamp.addItems(optionStr)
                self.guiTimestampL.setDisabled(False)
                self.guiTimestamp.setDisabled(False)

        if not self.currentDataset['selectByBBox']:
            self.guiFullExtentChbox.setChecked(True)
            self.updateSelectMode()
            self.guiGroupExtent.setDisabled(True)
        else:
            self.guiFullExtentChbox.setChecked(False)
            self.updateSelectMode()
            self.guiGroupExtent.setDisabled(False)
        
        self.unblockUiSignals()
        
    def clearOptions(self):
        """Deactivate and disable option drop down menus"""
        self.blockUiSignals()
        self.guiFormat.clear()
        self.guiFormat.setDisabled(True)
        self.guiFormatL.setDisabled(True)
        self.guiResolution.clear()
        self.guiResolution.setDisabled(True)
        self.guiResolutionL.setDisabled(True)
        self.guiCoordsys.clear()
        self.guiCoordsys.setDisabled(True)
        self.guiCoordsysL.setDisabled(True)
        self.guiTimestamp.clear()
        self.guiTimestamp.setDisabled(True)
        self.guiTimestampL.setDisabled(True)
        self.unblockUiSignals()
    
    def blockUiSignals(self):
        self.guiFormat.blockSignals(True)
        self.guiResolution.blockSignals(True)
        self.guiCoordsys.blockSignals(True)
        self.guiTimestamp.blockSignals(True)
        self.guiFullExtentChbox.blockSignals(True)
    
    def unblockUiSignals(self):
        self.guiFormat.blockSignals(False)
        self.guiResolution.blockSignals(False)
        self.guiCoordsys.blockSignals(False)
        self.guiTimestamp.blockSignals(False)
        self.guiFullExtentChbox.blockSignals(False)
        
    def onUnselectDataset(self):
        self.currentDataset = {}
        self.clearOptions()
        # self.clearExtent()

        self.guiGroupExtent.setDisabled(True)
        self.guiGroupFiles.setDisabled(True)
        self.guiDownloadBtn.setDisabled(True)
    
    def resetFileList(self):
        self.guiFileList.clear()
        self.guiDownloadBtn.setDisabled(True)
        self.guiFileListStatus.setText('')
    
    def onOptionChanged(self, newVal):
        self.resetFileList()
    
    def updateSelectMode(self):
        if self.guiFullExtentChbox.isChecked():
            bbox = QgsRectangle(*tuple(self.currentDataset['bbox']))
            self.updateExtentValues(bbox, self.apiRefSys)
    
    def getBbox(self) -> list:
        """Read out coordinates of bounding box, transform coordinates if
        necessary"""
        if self.guiFullExtentChbox.isChecked():
            return []
        
        rectangle: QgsRectangle = self.guiExtentWidget.currentExtent()
        llCoord = (rectangle.xMinimum(), rectangle.yMinimum())
        urCoord = (rectangle.xMaximum(), rectangle.yMaximum())

        # Cancel if there are no actual coords in input fields
        if not all(llCoord) or not all(urCoord):
            return []

        llPoint = QgsPoint(*tuple(llCoord))
        urPoint = QgsPoint(*tuple(urCoord))
        llPoint.transform(self.transformProj2Api)
        urPoint.transform(self.transformProj2Api)
        return [llPoint.x(),
                llPoint.y(),
                urPoint.x(),
                urPoint.y()]

    def onLoadFileList(self):
        """Collect options and call api to retrieve list of items"""
        # Remove current file list
        self.guiFileList.clear()
        
        # Read out extent
        bbox = self.getBbox()
        if float('inf') in bbox:
            bbox = []
            
        # Read out options
        options = {}
        timestamp = ''
        for optionKey, option in self.currentDataset['options'].items():
            if optionKey == 'format':
                options[optionKey] = option[self.guiFormat.currentIndex()]
            if optionKey == 'resolution':
                options[optionKey] = option[self.guiResolution.currentIndex()]
            if optionKey == 'coordsys':
                options[optionKey] = option[self.guiCoordsys.currentIndex()]
            if optionKey == 'timestamp':
                timestamp = option[self.guiTimestamp.currentIndex()]
        
        # Call api
        self.fileList = getFileList(self.currentDataset, bbox, timestamp, options)
        # Update file type filter and file list
        self.updateFilterList()
        self.filterFileList(self.currentFilter)
        
        # Enable download button
        if self.fileList:
            self.guiDownloadBtn.setDisabled(False)

        # task = QgsTask.fromFunction('heavy function', getFileList,
        #                             on_finished=self.displayFileList,
        #                             dataset=self.currentDataset, bbox=bbox,
        #                             options=options)
        # QgsApplication.taskManager().addTask(task)

    # def displayFileList(self, exception, files=None):
    #     if not exception:
    #         self.guiGroupFiles.setDisabled(False)
    #         self.guiDownloadBtn.setDisabled(False)
    #         self.guiFileListStatus.setText(f"{files['metadata']['count']} File(s) with a "
    #             f"total size of {files['metadata']['size']} MB are ready to be download.")
    #     else:
    #         QgsMessageLog.logMessage(f"Exception: {exception}",
    #                                  'MESSAGE_CATEGORY', Qgis.Critical)
    #         raise exception
    
    def updateFilterList(self):
        self.guiFileType.blockSignals(True)
        self.guiFileType.clear()
        # Get unique values from extension list and add to drop down
        fileTypeList = list(set([file['ext'] for file in self.fileList]))
        fileTypeList.insert(0, 'all')
        self.guiFileType.addItems(fileTypeList)
        # Set list to 'all'
        if self.currentFilter not in fileTypeList:
            self.currentFilter = 'all'
        
        self.guiFileType.setCurrentIndex(fileTypeList.index(self.currentFilter))
        self.guiFileType.blockSignals(False)
    
    def populateFileList(self, fileList):
        self.guiFileList.clear()
        fileNames = [file['id'] for file in fileList]
        if fileNames:
            self.guiFileList.addItems(fileNames)
        self.updateSummary()

    def filterFileList(self, filetype):
        if filetype == 'all':
            self.fileListFiltered = [file for file in self.fileList]
        else:
            self.fileListFiltered = [file for file in self.fileList if file['ext'] == filetype]
        self.currentFilter = filetype
        self.populateFileList(self.fileListFiltered)
    
    def updateSummary(self):
        if len(self.fileListFiltered) > 0:
            fileSize = sum([file['size'] for file in self.fileListFiltered])
            self.guiFileListStatus.setText(
                f"{len(self.fileListFiltered)} File(s) with a "
                f"total size of {filesizeFormatter(fileSize)} are ready to download.")
        else:
            self.guiFileListStatus.setText('No files found.')
    
    def onDownloadFiles(self):
        # Let user choose output directory
        if self.outputPath:
            openDir = self.outputPath
        else:
            openDir = os.path.expanduser('~')
        folder = QFileDialog.getExistingDirectory(self, 'Choose output folder',
                                                  openDir, QFileDialog.ShowDirsOnly)
        if folder:
            # Save path for later
            self.outputPath = folder
            # Check if there are files that are going to be overwritten
            waitForConfirm = False
            for file in self.fileListFiltered:
                savePath = os.path.join(folder, file['id'])
                if os.path.exists(savePath):
                    waitForConfirm = True
                    break
            
            if waitForConfirm:
                confirmed = self.showDialog('Overwrite files?',
                    'At least one file will be overwritten. Continue?')
                if not confirmed:
                    return

            exception = downloadFiles(self.fileListFiltered, folder)
            if exception:
                self.showDialog('Error', 'An error happened when requesting or saving data.', 'Ok')
                return
            
            # Confirm successful download
            self.guiFileListStatus.setText('Files successfully downloaded!')
            self.guiFileList.clear()
    
    @staticmethod
    def showDialog(title, msg, mode='OkCancel'):
        msgBox = QMessageBox()
        msgBox.setIcon(QMessageBox.Question)
        msgBox.setWindowTitle(title)
        msgBox.setText(msg)
        if mode == 'OkCancel':
            msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        elif mode == 'YesNo':
            msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        elif mode == 'error':
            msgBox.setIcon(QMessageBox.Critical)
            msgBox.setStandardButtons(QMessageBox.Ok)
        elif mode == 'Ok':
            msgBox.setStandardButtons(QMessageBox.Ok)
        else:
            msgBox.setStandardButtons(QMessageBox.Ok)
            
        returnValue = msgBox.exec()
        return returnValue == QMessageBox.Ok or returnValue == QMessageBox.Yes
